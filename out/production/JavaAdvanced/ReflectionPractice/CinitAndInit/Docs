一..clinit
    1.概述
        类型初始化方法<clinit>(类构造器)：
        JVM通过Classload进行类型加载时，如果在加载时需要进行类型初始化操作时，则会调用类型的初始化方法。
        类型初始化方法主要是对static变量进行初始化操作，对static域和static代码块初始化的逻辑全部封装在<clinit>方法中。
        Java类型初始化过程中对static变量的初始化操作依赖于static域和static代码块的前后关系，
        static域与static代码块声明的位置关系会导致java编译器生成<clinit>方法字节码。
        类型的初始化方法<clinit>只在该类型被加载时才执行，且只执行一次。

    2.注意事项：
        1. 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。
        2. 在执行clinit方法时，必须先执行父类的clinit方法。
        3. clinit方法只执行一次。
        4. static变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定。

二.init
    1.概述
        对象实例化方法<init>(实例构造器)：
        Java对象在被创建时，会进行实例化操作。该部分操作封装在<init>方法中，并且子类的<init>方法中会首先对父类<init>方法的调用。
        Java对象实例化过程中对实例域的初始化赋值操作全部在<init>方法中进行，<init>方法显式的调用父类的<init>方法，
        实例域的声明以及实例初始化语句块同样的位置关系会影响编译器生成的<init>方法的字节码顺序，<init>方法以构造方法作为结束。
        主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。
    2.注意事项：
        1.如果类中没有成员变量和代码块，那么clinit方法将不会被生成。
        2.在执行init方法时，必须先执行父类的init方法。
        3.init方法每实例化一次就会执行一次。
        4.init方法先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块。

三.init()和clinit()方法的区别
    <clinit>(类构造器)：在jvm进行类 加载--验证--解析--初始化，中的初始化阶段jvm会调用clinit方法。
            （在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行）。
             对静态变量，静态代码块进行初始化
    <init>(实例构造器):在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；
            调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。
            对非静态变量解析初始化

    class X {
       static Log log = LogFactory.getLog(); // <clinit>
       private int x = 1;   // <init>
       X(){
          // <init>
       }
       static {
          // <clinit>
       }
    }

    （1）<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static）中的语句合并产生的，
            编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，
            点贵在他之后的变量，在前面的静态语句块中可以赋值但不能访问。
        public class Test{
        static{
            i = 0;                                        //给变量赋值可以正常通过
            System.out.println(i);               //这句编译器会提示“非法向前引用”
        }
        static int i = 1;
        }
    （2）<clinit>()方法与类的构造函数（或者说实例构造器中的<init>()方法）不同， 它不需要显示的调用父类构造器，
            虚拟机会保证在子类的<init>()方法执行之前，父类的<clinit>()方法已经执行完毕。
            因为在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
    （3）由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类类的变量赋值操作。
    （4）<clinit>()方法对于类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有变量的赋值操作，
            那么编译器可以不为这个类生成<clinit>()方法。
    （5）接口中不能使用静态语句块，但仍然可以有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。
            但接口与类不同，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。
            只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
    （6）虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。
            如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞。