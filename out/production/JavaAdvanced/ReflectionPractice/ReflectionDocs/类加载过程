一.类加载过程概述
    1.什么是类的加载？如何理解？
        一个Java文件从编码完成到最终执行，一般主要包括两个过程 ： 编译 和 运行
            编译，把我们写好的java文件，通过javac命令编译成字节码文件，也就是我们常说的.class文件。
            运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。
            注：javac编译时不进行连接(分配内存)工作，而是在jvm运行时才动态加载和动态连接。
        而类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的Class对象的过程。
        比如，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，
        于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。
        加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。换句话说，Class的实例就对应着一个运行时类。
        由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。
        因为java存在一种机制：
            类缓存:标准的JavaSE类加载器可以按要求查找类，但- -旦某个类被加载到类加载器中，
            它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象。

    2.类的生命周期
        类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；
        在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载。

        从类的生命周期而言，类的加载过程有如下几个阶段:

            加载         连接         初始化             使用      卸载
            loading      Linking     Initialization    Using    Unloading

            而连接又分为三个阶段：
            验证            准备            解析
            Verification    Preparation    Resolution

        加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行，
        而解析阶段则不一定，它在某些情况下可能在初始化阶段后在开始，因为java支持运行时绑定。

    3.类加载方式
        这里的类加载不是指类加载阶段，而是指整个类加载过程，即类加载阶段到初始化完成。
        （1）隐式加载
            1.创建类对象
            2.使用类的静态域
            3.创建子类对象
            4.使用子类的静态域
            5.在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
            6.在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
            7.在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件
        （2）显式加载
            1.ClassLoader.loadClass(className)，只加载和连接、不会进行初始化
            2.Class.forName(String name, boolean initialize,ClassLoader loader); 使用loader进行加载和连接，根据参数initialize决定是否初始化。

二.加载阶段
    1.加载时机
        关于类什么时候被加载，Java虚拟机规范并没有做出硬性的规定，不同JVM可能有不同的实现。一般分为下面两种情况:
            饿汉式（eagerly load）：只要有其他类引用了它就加载（大概是指Test a;这种情况下就加载)
            懒汉式（lazy load）：类初始化的时候才加载

    2.加载阶段过程
        这个阶段jvm完成以下动作：
            首先类加载器通过类的全路径限定名读取类的二进制字节流，
            然后将二进制字节流代表的类结构转化到运行时数据区的方法区中，
            最后在jvm堆中生成代表这个类的java.lang.Class实例(不是这个类的实例)，作为方法区这个类的各种数据的访问入口。

        注：获取类的二进制流既可以使用jvm自带的类加载器，也可以使用自定义类加载器。
        相对于类生命周期的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，
        因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
        自定义类加载器（实现通过一个类的全限定名获取类的二进制字节流的动作放在jvm外部实现的模块）。

    3.加载.class文件的方式
         1）从本地系统中直接加载
         2）通过网络下载.class文件
         3）从zip，jar等归档文件中加载.class文件
         4）从专有数据库中提取.class文件
         5）将Java源文件动态编译为.class文件    

    4.类加载器
        1）概述
            类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。
            一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。
            在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。
            同一个加载器加载的同源类才是真的同类。不同加载器加载同源类，不是同类！instanceof 为FALSE。
            例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，
            则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：
            （Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。
            两个不同的jar包下，有两个类的全限定名一样(实现不一 样), 如何加载这两个类？
                只有一个会被加载，另外-个被加载时无法通过第一步的判断， 会从缓存中返回Class对象。

        2）类加载器关系及作用
        系统默认自带3个类加载器BootStrap、Extension、System(Application)。三个类加载器之间为父子关系（并非java中的父类子类关系）。
            Bootstrap为根加载器（由C++实现）,用c++实现为jvm的一部分(仅指sun的hotspot)，
                负责 JAVA_HOME/lib下面的类库中的类的加载，这个加载器，java程序无法引用到。是Extension加载器的父加载器；
            Extension为扩展加载器（由纯java实现），由sun.misc.Launcher$ExtClassLoader类实现，可在java中使用，
                负责JAVA_HOME/lib/ext目录和java.ext.dir目录中类库的类的加载。加载路径为jre/lib/ 和jre/lib/ext/下的类，是System的父加载器；
            System称为系统（也称为应用）类加载器（由纯java实现），由sun.misc.Louncher$AppClassLoader实现，
                它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。
                程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。
                如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。父类加载器为ExtClassLoader。

        3）自定义类加载器
            自定义加载器只需要继承ClassLoader这个抽象类重写FindClass方法。自定义加载器不传参数默认父加载器是System加载器，
            如果传入一个加载器则该加载器就是它的父加载器。所以父子加载器关系应该是组合关系，父子加载器有可能是父类和子类的关系有可能不是。

        4)类载器加载Class大致要经过如下8个步骤:
            1.检测此Class是否载入过，即在缓冲区中是否有此Class,如果有直接进入第8步，否则进入第2步。
            2.如果没有父类加载器(要么Parent是根类加载器，要么本身就是根类加载器)，则跳到第4步,如果父类加载器存在，则进入第3步。
            3.请求使用父类加载器去载入目标类,如果载入成功则跳至第8步，否则接着执行第5步。
            4.请求使用根类加载器去载入目标类,如果载入成功则跳至第8步，否则跳至第7步。
            5.当前类加载器尝试寻找Class文件，如果找到则执行第6步,如果找不到则执行第7步。
            6.从文件中载入Class,成功后跳至第8步。
            7.抛出ClassNotFountException异常。
            8.返回对应的java.lang.Class对象。

        5)类加载机制
        JVM的类加载机制主要有如下3种：
            全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，
                除非显示使用另外一个类加载器来载入。
            双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
                通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，
                依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
            缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，
                只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。
                这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

        6)类加载的双亲委派模型
            根类加载器 <--- 扩展类加载器 <--- 系统类加载器 <--- 用户类加载器

            双亲委派机制概述：
            各个加载器都是先委托自己的父加载器加载类，若确实没加载到再自己来加载。所以java默认的类查找加载顺序是自顶向下的树状结构。
            双亲委托的意图是保证java类型体系中最基础的行为一致，优先加载JDK中的类。

            双亲委派机制工作原理:
                如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，
                如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
                如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，
                这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
            双亲委派机制的优势：
                采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，
                当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
                其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，
                通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，
                并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，
                这样便可以防止核心API库被随意篡改。

        7)命名空间
            每个类加载器都有自己的命名空间，命名空间由类加载器和它所有的父加载器所加载的类组成，
            在同一个命名空间中不会出现类的完整名字相同（包括包名）的两个类；
            不在同一个命名空间中有可能出现类的完整名字相同（包括包名）的类；不同命名空间的类相互不可见，
            所以同一个类可以被不同加载器加载多次，只要这些类加载器没有直接和间接的父子关系即可。
            子加载器加载的类的命名空间包含所有父加载器所加载的类的命名空间，因此由子加载器加载的类能够看见父加载器加载的类。
            由父加载器加载的类不能看见由子加载器加载的类，如果两个加载器之间没有直接或间接的父子关系，那么由这两个加载器加载的类相互不可见。

        8）运行时包
            由同一个加载器加载的相同包的类组成了运行时包，决定两个类是否是属于同一个运行时包，
            不仅要看包名是否相同，还要看加载该类的加载器是否是同一个类加载器。
            只有属于同一运行时包的类才能彼此访问包内默认权限的内容。
            例如java.lang.Object类是由Bootstrap类加载器加载的，但是你也可以自己定义一个java.lang包，
            里面写一个类GetObjectProtected,一般情况下java.lang.GetObjectProtected这个类可以由System类加载器成功加载。
            如果没有这个运行时包这个限制，jvm就会认为GetObjectProtected类和系统中的java.lang包中Object类是属于同一个包，
            那么GetObjectProtected就可以访问Object类中的所有包访问权限的属性和调用Object中protected方法。
            而这些包权限的属性和方法是只希望被系统java.lang包内的方法访问，这样的话就有可能会危害到jvm的安全，
            所以就用类运行时包来进行限制。

三.连接阶段（验证、准备、解析）
    当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。
    类连接又可分为如下3个阶段（验证、准备、解析）。
    1.验证
        验证阶段确保被加载的类的正确性：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

        文件格式验证：验证字节流是否符合Class文件格式的规范，
            如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。
        元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；
            如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。
        字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，
            如：操作数栈的数据类型与指令代码序列能配合工作，保证方法中的类型转换有效等等。
        符号引用验证：确保解析动作能正确执行；
            如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等。

        验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施。

    2.准备
        准备阶段是为类的静态变量分配内存，并将其赋默认值（基本数据类型为0，引用数据类型默认值为null）。

        为类变量（注意，不是实例变量）分配内存并设置类变量初始值，这些内存都将在方法区中分配。
        对于该阶段有以下几点需要注意：
            初始值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。
            只对static修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。
            对final的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）。
            例如：比如8种基本类型的初值，默认为0；引用类型的初值则为null；
                常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456。

    3.解析
        解析阶段是将常量池中的符号引用替换为直接引用（内存地址）的过程。
        符号引用就是一组符号来描述目标，可以是任何字面量。
            属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
        直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
            如指向方法区某个类的一个指针。
        假设：一个类有一个静态变量，该静态变量是一个自定义的类型，那么经过解析后，该静态变量将是一个指针，指向该类在方法区的内存地址。
四.初始化
    1.初始化阶段概述
    初始化阶段是为类的静态变量赋值，包括定义时赋值和静态代码块赋值；按顺序从上到下依次执行。
    换句话说，只对static修饰的变量或语句进行初始化。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

    2.类初始化时机
        主动引用（首次）
            1.创建某个类的新实例时--new, 反射, 克隆 或 反序列化。(T t = new T（）)
            2.访问某个类或接口的静态方法或静态变量,或者对静态变量赋值。(T.staticField（）\T.staticField = o\Object o = T.staticField)
            3.反射(Class.forName("com.lyj.load")（ClassLoader.loadClass()仅仅是将类加载到内存中，不会进行初始化）。
            4.初始化一个类的子类(会首先初始化子类的父类)。
            5.JVM启动时标明的启动类，即文件名和类名相同的那个类（main（）方法所在类）。
            除此之外，下面几种情形需要特别指出:
            对于一个final类型的静态变量,如果该变量的值在编译时就可以确定下来，那么这个变量相当于"宏变量”。
            Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。
            反之,如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值,
            如果通过该类来访问它的静态变量，则会导致该类被初始化。
        被动引用
            1.通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化。
            2.定义对象数组和集合,不会触发该类的初始化
            3.类A引用类B的static final常量不会导致类B初始化(注意静态常量必须是字面值常量，否则还是会触发B的初始化)
            4.通过类名获取Class对象,不会触发类的初始化。如System.out.println(Person.class);
            5.通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化。
            6.通过ClassLoader默认的loadClass方法, 也不会触发初始化动作
            注意:被动引用不会导致类初始化，但不代表类不会经历加载、验证、准备阶段。

    3.子类继承父类时的初始化顺序
        1.首先初始化父类的static变量和块，按出现顺序
        2.初始化子类的static变量和块，按出现顺序
        3.初始化父类的普通变量，调用父类的构造函数
        4.初始化子类的普通变量,调用子类的构造函数

    4.初始化阶段和连接阶段的准备过程关系？
        初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的。
        如果类中有语句：private static int a = 10，它的执行过程是这样的，
        首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，
        因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后解析，
        到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。
        准备是为static变量赋初始默认值，而初始化时为static变量人为赋值。

五.卸载
    类卸载时机
    1.执行了System.exit()方法
    2.程序正常执行结束
    3.程序在执行过程中遇到了异常或错误而异常终止
    4.由于操作系统出现错误而导致Java虚拟机进程终止

六.clinit 与 init (详情见CinitAndInit\\Docs)
    在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。
    1.clinit 
        类型初始化方法<clinit>(类构造器)：
        JVM通过Classload进行类型加载时，如果在加载时需要进行类型初始化操作时，则会调用类型的初始化方法。
        类型初始化方法主要是对static变量进行初始化操作，对static域和static代码块初始化的逻辑全部封装在<clinit>方法中。
        Java类型初始化过程中对static变量的初始化操作依赖于static域和static代码块的前后关系，
        static域与static代码块声明的位置关系会导致java编译器生成<clinit>方法字节码。
        类型的初始化方法<clinit>只在该类型被加载时才执行，且只执行一次。

        注意事项：
            1. 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。
            2. 在执行clinit方法时，必须先执行父类的clinit方法。
            3. clinit方法只执行一次。
            4. static变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定。
    2.init
        对象实例化方法<init>(实例构造器)：
        Java对象在被创建时，会进行实例化操作。该部分操作封装在<init>方法中，并且子类的<init>方法中会首先对父类<init>方法的调用。
        Java对象实例化过程中对实例域的初始化赋值操作全部在<init>方法中进行，<init>方法显式的调用父类的<init>方法，
        实例域的声明以及实例初始化语句块同样的位置关系会影响编译器生成的<init>方法的字节码顺序，<init>方法以构造方法作为结束。
        主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。
        注意事项：
            1. 如果类中没有成员变量和代码块，那么clinit方法将不会被生成。
            2. 在执行init方法时，必须先执行父类的init方法。
            3. init方法每实例化一次就会执行一次。
            4. init方法先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块。
